class threadSafe(){

typedef boost::shared_mutex Lock;
typedef boost::unique_lock<Lock> WriteLock;
typedef boost::shared_lock<Lock> ReadLock;

	Lock r_w_lock;

	public:

	vector<int> data;

	threadSafe(){
		WriteLock wLock(r_w_lock);

		for(int i = 0 ; i < 10 ; i++)
			data.push_back(i);

		writeAll(0);
	}

	writeOne(int index, int value){
		WriteLock wLock(r_w_lock); //!!!DEADLOCK!!! if WriteAll is called, the read lock 
		if(index >=0 && index <data.size()){
			data[index] = value;
		}
	}

	writeAll(int value){
		//we need read access to obtain data.size()
		ReadLock rLock(r_w_lock); //this is a shared_mutex
		for(int i = 0 ; i < data.size() ; i++)
			writeOne(i,value);
	}

}
